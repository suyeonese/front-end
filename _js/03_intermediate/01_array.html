<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>자바스크립터 배열 : 유동배열</title>
</head>
<body>
    <h1>
        자바스크립트의 배열은 유동배열 : 크기와 데이터의 변경이 가능하다
    </h1>
    <ul>
        <li>
            const myFavors = ['a', 'b', 'c', 1, 2, 3];
        </li>
        <li>
            원래 데이터 타입이 같아야 하지만 자바스크립트는 허용을 하고 있다
        </li>
        <li>
            myFavors = []; 초기값이 없는 빈 배열을 만든 후 데이터를 추가하여 크기변경이 가능하다
        </li>
        <li>
            각 데이터들은 콤마(,)로 분리되고 분리 된 자리는 index로 관리되며 0부터 시작한다
        </li>
        <li>
            크기는 length(길이)라는 속성을 사용하여 측정하고 크기가 변경될 때마다 자동으로 산정된다
        </li>
        <li>
            인덱스 번호 체계에서 순서의 뛰어넘음 등의 변칙적인 사용은 모두 undefined로 초기화된다
        </li>
        <li> 
            객체와 달리 index로 관리되고(=숫자로 관리, 정확함) 다양한 데이터를 저장할 수 있기 때문에 
            자바스크립트 프로그래밍에서 활용도가 매우 높으며 이해도가 낮으면 
            추후 데이터 통신 및 데이터 변환에서 프로그래밍이 힘들 수 있다 
        </li>
    </ul>
    <script>
        // const myFavors = new Array('a', 1, 2, 3); 가급적이면 사용하지 말 것!
        const myFavors = ['a', "b", `c`, 1, 2, 3];
        console.log(myFavors.length); // 6 
        console.log(myFavors[5]); // [6-1] => 3
        console.log(myFavors[myFavors.length-1]); // 3 => 배열의 크기를 알 수 없을 때 myFavors[myFavors.length - 1]
        console.log(myFavors);

        // 배열의 원소 추가 : 배열의 길이를 모른다고 가정했을 때
        myFavors[myFavors.length] = 'add';
        console.log(myFavors);

        myFavors[myFavors.length + 3] = 'new'; // myFavors[10] = 'new';
        console.log(myFavors[7]);
        console.log(myFavors[8]);
        console.log(myFavors[9]);
        console.log(myFavors);

        myFavors[8] = 'filled';
        console.log(myFavors);

        console.log('============================');
        //myFavors = []; // const로 배열을 선언했을 때 배열의 값은 바꿀 수 있어도 배열구조 자체를 변경할 수는 없다!
        //배열의 초기화가 필요한 로직은 let으로 선언한다!
        console.log(myFavors);

        // 원래 배열은 같은 데이터 타입만을 배열의 원소로 사용하는 것이 원칙이다
        // 현재 다른 타입의 데이터들과 혼합된 형태로 만들어서 사용하는 것도 많다
        // 유사배열(연관배열) : associative array => 배열관련 메서드를 사용할 수 없음
        let originArrayType = [10, 20, 30, 40, 50];
        let assocArrayType = [1, true, 'kim', undefined, {k: 'value'},['k', 'b']];
        console.log(assocArrayType[0]);
        let a = 'k';
        console.log(assocArrayType[assocArrayType.length-2].k); // 객체 k
        console.log(assocArrayType[assocArrayType.length-1][0]); // 배열의 0번 둘 다 못할 경우에는 주석을 달거나 `{}` 백틱이라도 써서 알려주는 것이 매너!

        console.log('=============1==============');
        for (let i = 0; i < originArrayType.length; i++) { 
            console.log(originArrayType[i]);
        }

        for (let i = 0; i <assocArrayType.length; i++) { // 스탠다드 for문: 인덱스번호로 찾을 수 있음
            if (i == 4) {
                console.log(typeof assocArrayType[i], assocArrayType[i]);
                console.log(assocArrayType[i].k);
            }else {
                console.log(typeof assocArrayType[i], assocArrayType[i]);
            }
        }

        console.log('=============2=============');
        for (let elem of assocArrayType) { // assocArrayType에 있는 elem을 뽑아오겠다.
            console.log(typeof elem, elem); //  전체 순회용, 인덱스번호 4번은 찾을 수 없음 
        }
    </script>
</body>
</html>